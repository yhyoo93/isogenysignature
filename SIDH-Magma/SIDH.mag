////////////////////////////////////////////////////////////////////////////////
//                                                               
// Efficient algorithms for supersingular isogeny Diffie-Hellman 
// Craig Costello, Patrick Longa, Michael Naehrig, 2016         
// (c) 2016 Microsoft Corporation. All rights reserved.         
//                                                                               
////////////////////////////////////////////////////////////////////////////////
//                                                                   
// Code for SIDH key exchange      
//                                                                   
////////////////////////////////////////////////////////////////////////////////
// 
// This is the main script that contains all the functions needed for SIDH key
// exchange. For the 4 stages of SIDH key exchange (i.e. Alice's key
// generation, Bob's key generation, Alice's shared secret and Bob's shared
// secret computation), it performs the isogeny computation/evaluation using two
// different strategies: 
// (1) the slow but simple "scalar-multiplication-based" strategy,
// (2) a fast way to traverse the isogeny tree using an optimal strategy.
//
////////////////////////////////////////////////////////////////////////////////

clear;

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// Public parameters /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Paramters defining the prime p = f*lA^eA*lB^eB - 1
f:=1;
lA:=2;
lB:=3;
eA:=372;
eB:=239;

// Define the prime p 
p:=f*lA^eA*lB^eB-1;
assert IsPrime(p: Proof:=false); 

// or, explicitly...
assert p eq 
1035471774176930525297776823786680532142738964554907117011618967905467894068247\
8846502882896561066713624553211618840202385203911976522554393044160468771151816\
976706840078913334358399730952774926980235086850991501872665651576831;

// Prime field of order p
Fp:=GF(p); 
// The quadratic extension via x^2 + 1 since p = 3 mod 4 
Fp2<i>:=ExtensionField<Fp,x|x^2+1>;  

// Bitlengths of group orders lA^eA and lB^eB, needed during the ladder
// functions 
eAbits:=eA;		
eBbits:=379;

// E0 is the starting curve E0/Fp2: y^2=x^3+x (the A=0 Montgomery curve)
E0:=EllipticCurve([Fp2|1,0]);
assert IsSupersingular(E0);

// The orders of the points on each side
oA:=lA^eA; 
oB:=lB^eB;

// Identifyers for Alice and Bob
Alice:=0;
Bob:=1;

// Generator PA for the base field subgroup of order lA^eA
PA:=3^239*E0![11,Sqrt(Fp!11^3+11)];
// Generator PB for the base field subgroup of order lB^eB
PB:=2^372*E0![6,Sqrt(Fp!6^3+6)];

////////////////////////////////////////////////////////////////////////////////
///////////////////////  Generator point coordinates ///////////////////////////
/////////////////// specified explicitly by 4 Fp elements //////////////////////
////////////////////////////////////////////////////////////////////////////////

XPA:=Fp!57843070331575741623916724745225229838323045112189057077049620587995724\
6271947419276998036192253718730996052447524118652730054908853394186541287466114\
3122262830946833377212881592965099601886901183961091839303261748866970694633; 

YPA:=Fp!55289417931846173645114523009626950849421654600788978815806665527365554\
1827349664589467431477400107235381696676468949309812255666275584200196978168790\
9521301233517912821073526079191975713749455487083964491867894271185073160661;

assert XPA eq PA[1] and YPA eq PA[2];

XPB:=Fp!43599173968491012310533367637003008929150967000137042101947814578014127\
3164398836738987088688433645324515677545433624919918565425015905192997560085704\
7173121187832546031604804277991148436536445770452624367894371450077315674371;

YPB:=Fp!10686693760744079753638500261776672082694467465027140072103951425088918\
6719923133049487966730514682296643039694531052672873754128006844434636819566554\
364257913332237123293860767683395958817983684370065598726191088239028762772;

assert XPB eq PB[1] and YPB eq PB[2];

////////////////////////////////////////////////////////////////////////////////
/////////////////// Strategies for traversing isogeny trees ////////////////////
////////////////////////////////////////////////////////////////////////////////

/*
   These are optimal strategies with respect to the cost ratios of 
   scalar multiplication by 4 and 4-isogeny evaluation of 
                     pA/qA = 2*12.9/22.8,
   and of point tripling and 3-isogeny evaluation of 
                     pB/qB = 27.8/17.0. 

   See the file optimalstrategies.txt for how they are computed.
*/

splits_Alice := [
 0, 1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 5, 6, 7, 8, 8, 8, 8, 8, 9, 10, 9, 12, 
11, 11, 12, 12, 13, 14, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 19, 19, 
17, 18, 19, 20, 21, 22, 21, 23, 22, 24, 24, 25, 25, 27, 27, 27, 28, 30, 30, 
31, 32, 32, 33, 33, 33, 33, 32, 33, 33, 33, 33, 33, 33, 33, 33, 36, 34, 35, 
34, 35, 38, 37, 38, 38, 39, 38, 41, 39, 43, 38, 41, 42, 43, 43, 40, 41, 42, 
43, 44, 45, 46, 47, 48, 49, 50, 48, 49, 53, 51, 51, 51, 53, 55, 56, 55, 56, 
58, 58, 58, 59, 61, 61, 63, 63, 64, 64, 64, 65, 65, 65, 64, 64, 65, 65, 65, 
66, 67, 65, 66, 65, 68, 66, 65, 66, 65, 66, 67, 65, 66, 67, 68, 69, 70, 71, 
72, 71, 72, 71, 76, 71, 76, 72, 71, 76, 71, 73, 72, 76, 76, 73, 73, 72, 76, 
76, 75, 76, 76, 75, 81, 81, 83, 81 ];

splits_Bob := [
 0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 
12, 12, 12, 12, 12, 12, 12, 13, 14, 14, 15, 16, 16, 16, 16, 17, 16, 19, 17, 
19, 19, 19, 20, 21, 22, 22, 22, 22, 22, 22, 22, 24, 22, 22, 24, 24, 26, 27, 
27, 28, 28, 28, 30, 28, 28, 28, 29, 28, 28, 28, 29, 29, 30, 33, 33, 33, 33, 
34, 35, 37, 37, 37, 38, 38, 38, 37, 38, 38, 38, 38, 38, 39, 38, 44, 43, 44, 
39, 40, 41, 43, 43, 43, 45, 46, 46, 46, 47, 48, 48, 49, 49, 50, 51, 51, 49, 
49, 50, 51, 50, 51, 50, 50, 51, 50, 51, 51, 51, 53, 55, 55, 55, 56, 56, 56, 
56, 56, 57, 58, 61, 61, 61, 63, 63, 63, 64, 65, 66, 65, 66, 66, 66, 65, 66, 
66, 66, 66, 66, 68, 71, 66, 66, 68, 67, 71, 66, 66, 68, 67, 71, 66, 66, 68, 
68, 71, 70, 70, 72, 72, 76, 75, 75, 78, 78, 78, 80, 80, 80, 80, 81, 81, 81, 
82, 83, 84, 85, 86, 86, 86, 86, 86, 86, 88, 86, 90, 86, 92, 87, 86, 89, 86, 
92, 87, 86, 87, 86, 91, 89, 89, 90, 90, 92, 92, 92, 93, 93, 93, 95, 95, 95, 
95, 95, 95, 95, 95 ];

////////////////////////////////////////////////////////////////////////////////
///////////////////////// Arithmetic functions /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

j_inv:=function(A,C); 

	/*
	Computes the j-invariant of a Montgomery curve with projective constant.

	Input:  
    - The projective curve constant (A:C) given by A,C in Fp2.

	Output: 
    - The j-invariant j=256*(A^2-3*C^2)^3/(C^4*(A^2-4*C^2)) of the Montgomery 
      curve B*y^2=x^3+(A/C)*x^2+x or (equivalently) the j-invariant of 
      B'*y^2=C*x^3+A*x^2+C*x.
	*/

	jinv:=A^2;		
	t1:=C^2;
	t0:=t1+t1;
	t0:=jinv-t0;
	t0:=t0-t1;
	jinv:=t0-t1;
	t1:=t1^2;
	jinv:=jinv*t1;
	t0:=t0+t0;
	t0:=t0+t0;
	t1:=t0^2;
	t0:=t0*t1;
	t0:=t0+t0;
	t0:=t0+t0;
	jinv:=1/jinv; 
	jinv:=t0*jinv;

	return jinv;		// Total: 3M+4S+8a+1I

end function;

////////////////////////////////////////////////////////////////////////////////

xDBLADD:=function(XP,ZP,XQ,ZQ,xPQ,A24)

	/*
	Carries out a typical step in the Montgomery ladder: a simultaneous 
    doubling and differential addition.
	
    Input: 
    - The projective Montgomery x-coordinates of xP=XP/ZP and xQ=XQ/ZQ, 
    - the affine difference x(P-Q) and 
    - the Montgomery curve constant A24=(A+2)/4.

	Output: 
    - The projective Montgomery x-coordinates of x(2P)=X2P/Z2P and
      x(Q+P)=XQP/ZQP.
	*/
        
    t0:= XP+ZP;
    t1:= XP-ZP;
    X2P:= t0^2;
    t2:= XQ-ZQ;
    XQP:= XQ+ZQ;
    t0:= t0*t2;
    Z2P:= t1^2;
    t1:= t1*XQP;
    t2:=X2P-Z2P;
    X2P:= X2P*Z2P;
    XQP:=A24*t2;
    ZQP:= t0-t1;
    Z2P:=XQP+Z2P;
    XQP:=t0+t1;
    Z2P:= Z2P*t2;
    ZQP:=ZQP^2;
    XQP:=XQP^2;
    ZQP:=xPQ*ZQP;
    
    return X2P,Z2P,XQP,ZQP;		// Total: 6M+4S+8a

end function;

////////////////////////////////////////////////////////////////////////////////

xADD:=function(XP,ZP,XQ,ZQ,xPQ)

	/*
	Computes a standard Montgomery differential addition.
 
	Input: 
    - The projective Montgomery x-coordinates of xP=XP/ZP and xQ=XQ/ZQ, 
    - and the affine difference x(P-Q).
	
    Output: 
    - The projective Montgomery x-coordinates of x(Q+P)=XQP/ZQP.
	*/

    t0:= XP+ZP;
    t1:= XP-ZP;
    XP:= XQ-ZQ;
    ZP:= XQ+ZQ;
    t0:= XP*t0;
    t1:= ZP*t1;
    ZP:=t0-t1;
    XP:=t0+t1;
    ZP:=ZP^2;
    XQP:=XP^2;
    ZQP:= xPQ*ZP;

    return XQP,ZQP;		// Total: 3M+2S+6a

end function;

////////////////////////////////////////////////////////////////////////////////

xDBL:=function(X,Z,A24,C24)

	/*
	This is NOT the stereotypical Montgomery x-only doubling, since it assumes 
    that the curve constant is projective.  

	Input: 
    - The projective Montgomery x-coordinates of xP=XP/ZP and 
    - the Montgomery curve constant A24/C24 = (A/C+2)/4.
	
    Output: 
    - The projective Montgomery x-coordinates of x(2P)=X2P/Z2P. 
	*/

    t0 := X-Z;           
	t1 := X+Z; 
	t0 := t0^2; 
	t1 := t1^2; 
	Z2 := C24*t0; 
	X2 := Z2*t1;
    t1 := t1-t0; 
	t0 := A24*t1;
	Z2 := Z2+t0;
	Z2:= Z2*t1;

	return X2,Z2;	// Total: 4M+2S+4a

end function;

////////////////////////////////////////////////////////////////////////////////

xDBLe:=function(XP,ZP,A,C,e)

	/*
	This just computes [2^e](X:Z) on the Montgomery curve with projective 
    constant (A:C) via 2^e repeated doublings.
  
	Input: 
    - The projective Montgomery x-coordinates of xP=XP/ZP and 
    - the Montgomery curve constant A/C.
	
    Output: 
    - The projective Montgomery x-coordinates of x(2^e*P)=XeP/ZeP. 
	*/

	A24num:=C+C;
	A24den:=A24num+A24num;
	A24num:=A24num+A;

	XeP:=XP; ZeP:=ZP;

	for i:=1 to e do
		XeP,ZeP:=xDBL(XeP,ZeP,A24num,A24den);
	end for;

	return XeP,ZeP;   

end function;

////////////////////////////////////////////////////////////////////////////////

xDBL_basefield:=function(X,Z,A24,C24)

	/*
	This is NOT the stereotypical Montgomery x-only doubling, since it assumes 
    that the curve constant is projective. All computations are over the base 
    field.

	Input: 
    - The projective Montgomery x-coordinates of xP=XP/ZP and 
    - the Montgomery curve constant A24/C24:=(A/C+2)/4.

	Output: 
    - The projective Montgomery x-coordinates of x(2P)=X2P/Z2P.
	*/
    
    // NOTE: this function assumes that A24=1, C24=2 are fixed.
    assert A24 eq 1;
    assert C24 eq 2;
        
    t0 := X-Z;           
	t1 := X+Z; 
	t0 := t0^2; 
	t1 := t1^2; 
	Z2 := t0+t0; 
	X2 := Z2*t1;
    t1 := t1-t0; 
	Z2 := Z2+t1;
	Z2:= Z2*t1;

	return X2,Z2;    // Total: 2M+2S+5a

end function;

////////////////////////////////////////////////////////////////////////////////

xDBLADD_basefield:=function(XP,ZP,XQ,ZQ,xPQ,A24,C24)

	/*
	This function carries out a typical step in the Montgomery ladder: 
    simultaneous doubling and differential addition. All computations are over 
    the base field.

	Input: 
    - The projective Montgomery x-coordinates of xP=XP/ZP and xQ=XQ/ZQ, 
    - the affine difference x(P-Q) and 
    - the Montgomery curve constant A24=(A+2)/4.

	Output: 
    - The projective Montgomery x-coordinates of x(2P)=X2P/Z2P and
      x(Q+P)=XQP/ZQP.
	*/
    
    // NOTE: this function assumes that A24=1, C24=2 are fixed.
    assert A24 eq 1;
    assert C24 eq 2;
          
    t0:= XP+ZP;
    t1:= XP-ZP;
    X2P:= t0^2;
    t2:= XQ-ZQ;
    XQP:= XQ+ZQ;
    t0:= t0*t2;
    Z2P:= t1^2;
    t1:= t1*XQP;
    t2:=X2P-Z2P;
    Z2P:=Z2P+Z2P;
    X2P:= X2P*Z2P;
    Z2P:=t2+Z2P;
    ZQP:= t0-t1;
    XQP:=t0+t1;
    Z2P:= Z2P*t2;
    ZQP:=ZQP^2;
    XQP:=XQP^2;
    ZQP:=xPQ*ZQP;
    
    return X2P,Z2P,XQP,ZQP;    // Total: 5M+4S+9a

end function;

////////////////////////////////////////////////////////////////////////////////

LADDER:=function(x,m,A24,C24,AliceOrBob)

	/*
	The legendary Montgomery ladder.

	Input: 
    - The affine x-coordinate of a point on E: B*y^2=x^3+A*x^2+x, 
    - a scalar m, and 
    - the curve constant (A+2)/4.

    Output:
    - The projective x-coordinates of x(mP)=X0/Z0 and x((m+1)P)=X1/Z1. 
	*/

	bits:=IntegerToSequence(m,2);
    
    // NOTE: this function assumes that A24=1, C24=2 are fixed.
    A24:=1; C24:=2;
	X0:=1; Z0:=0;      // Initializing with the point at infinity and (x,1)
	X1:=x; Z1:=1;

    if (AliceOrBob eq Alice) then 
        nbits:=eAbits;
    else 
        nbits:=eBbits;
    end if;

    for i:=1 to (nbits-#bits) do
            X0,Z0,X1,Z1:=xDBLADD_basefield(X0,Z0,X1,Z1,x,A24,C24);
    end for;

    for i:=#bits to 1 by -1 do
        if bits[i] eq 0 then
            X0,Z0,X1,Z1:=xDBLADD_basefield(X0,Z0,X1,Z1,x,A24,C24);
        else
            X1,Z1,X0,Z0:=xDBLADD_basefield(X1,Z1,X0,Z0,x,A24,C24);
        end if;
    end for;

    return X0,Z0,X1,Z1;

end function;

////////////////////////////////////////////////////////////////////////////////

secret_pt:=function(x,y,m,AliceOrBob)
	
	/*
	Computes key generation ***entirely in the base field*** by exploiting a 
    1-dimensional Montgomery ladder in the trace zero subgroup and recovering 
    the y-coordinate for the addition. All operations below are in the base 
    field Fp.

	Input: 
    - A point P=(x,y) on E in the base field subgroup,
    - the point Q=(-x,y*i) on E in the trace-zero subgroup, and
    - the scalar m.

	Output: 
    - Field elements RX0,RX1,RZ in Fp such that (RX0+RX1*i)/RZ is the 
      x-coordinate of P+[m]Q. 
	*/
    
    // NOTE: this function assumes that A24=1, C24=2 are fixed.
    A24:=1; C24:=2;
    X0,Z0,X1,Z1:=LADDER(-x,m,A24,C24,AliceOrBob);

	RZ:=x*Z0; 
    RX0:=X0*x;   
    t4:=X0+RZ;
    RZ:=X0-RZ;
    t0:=t4^2;    
    RX0:=Z0-RX0;
    t0:=t0*X1;
    RX0:=RX0*RZ;
	t2:=y*Z1;
	t1:=y*Z0;
	t2:=t2+t2;
	RX1:=t2*Z0;
    RX0:=RX0*Z1;
	RX0:=RX0-t0;
	t1:=t1*RX1;
	t0:=RX1^2;
	t2:=t2*RX1;
	RX1:=t1*RX0; 
	t3:=t1+RX0;
	RX1:=RX1+RX1; 
	t1:=t1-RX0;
	t1:=t1*t3;
	RZ:=RZ^2;
	t2:=t2*t4;
	t2:=t2*RZ;
	RZ:=t0*RZ;  
	RX0:=t1-t2;

    return RX0,RX1,RZ;    // Total: 15M+3S+9a 

end function;

////////////////////////////////////////////////////////////////////////////////

LADDER_3_pt:=function(m,xP,xQ,xPQ,A,AliceOrBob)
	
	/*
	This is Algorithm 1 of De Feo, Jao and Plut. It computes P+[m]Q via x-only 
    arithmetic.
	
    Input: 
    - The three affine points xP,xQ,xPQ (they are affine as they are compressed 
      before transmission over the wire) and 
    - the Montgomery constant A.
	
    Output: 
    - The projective Montgomery x-coordinates of x(P+[m]Q)=WX/WZ. 
	*/

	bits:=IntegerToSequence(m,2);

	A24num:=A+2;   //tailored for the special xDBL function
	A24:=A24num/2;
	A24:=A24/2; 
    
	UX:=1; UZ:=0;  // Initializing with point at infinity (1:0), 
	VX:=xQ; VZ:=1; // (xQ:1) and
	WX:=xP; WZ:=1; // (xP:1)

    if (AliceOrBob eq Alice) then 
        nbits:=eAbits;
    else 
        nbits:=eBbits;
    end if;

    for i:=1 to (nbits-#bits) do
			WX,WZ:=xADD(UX,UZ,WX,WZ,xP);
			UX,UZ,VX,VZ:=xDBLADD(UX,UZ,VX,VZ,xQ,A24);
    end for;

	for i:=#bits to 1 by -1 do

		if bits[i] eq 0 then
			WX,WZ:=xADD(UX,UZ,WX,WZ,xP);
			UX,UZ,VX,VZ:=xDBLADD(UX,UZ,VX,VZ,xQ,A24);
		else
			UX,UZ:=xADD(UX,UZ,VX,VZ,xQ);
			VX,VZ,WX,WZ:=xDBLADD(VX,VZ,WX,WZ,xPQ,A24);
		end if;

	end for;

	return WX,WZ;

end function;

////////////////////////////////////////////////////////////////////////////////

get_4_isog:=function(X4,Z4)
	
	/*
	Given a projective point (X4:Z4) of order 4 on a Montgomery curve, this 
    computes the corresponding 4-isogeny.

	Input: 
    - The projective point of order four (X4:Z4).

	Output: 
    - The 4-isogenous Montgomery curve with projective coefficient A/C and 
      the 5 coefficients that are used to evaluate the isogeny at a point 
      (see the next function).
	*/

	coeff0:=X4+Z4;          
	coeff3:=X4^2;
	coeff4:=Z4^2;
	coeff0:=coeff0^2;
    coeff1:=coeff3+coeff4;
	coeff2:=coeff3-coeff4;
	coeff3:=coeff3^2;
	coeff4:=coeff4^2;
	A:=coeff3+coeff3;
    coeff0:=coeff0-coeff1;
	A:=A-coeff4;
	C:=coeff4;
	A:=A+A;				// Total: 5S+7a

	return A,C,[coeff0,coeff1,coeff2,coeff3,coeff4]; 

end function;

////////////////////////////////////////////////////////////////////////////////

eval_4_isog:=function(coeff,X,Z)

	/*
	Given a 4-isogeny phi defined by the 5 coefficients in coeff (computed in 
    the function get_4_isog), evaluates the isogeny at the point (X:Z) in the 
    domain of the isogeny.

	Input: 
    - The coefficients defining the isogeny, and 
    - the projective point P=(X:Z).

	Output: 
    - The projective point phi(P)=(X:Z) in the codomain. Variables are 
      overwritten because they replace inputs in the routine.
	*/

	X:=coeff[1]*X;
	t0:=coeff[2]*Z;
	X:=X-t0;
	Z:=coeff[3]*Z;
	t0:=X-Z;
	Z:=X*Z;
	t0:=t0^2;
	Z:=Z+Z;
	Z:=Z+Z;
	X:=t0+Z;
	Z:=t0*Z;
	Z:=coeff[5]*Z;
	t0:=t0*coeff[5];
	t1:=X*coeff[4];
	t0:=t0-t1;
	X:=X*t0;				// Total: 9M+1S+6a

	return X,Z;	
	
end function;

////////////////////////////////////////////////////////////////////////////////

first_4_isog:=function(X4,Z4,A)

	/*
	This is the very first 4-isogeny computed by Alice, which is different
    from all subsequent 4-isogenies because the point (1,..) is already in the 
    kernel, so it doesn't need composition with the preliminary isomorphism.
    (See De Feo, Jao and Plut, Section 4.3).

	Input: 
    - The projective point (X4:Z4) and 
    - the curve constant A (that is affine because it is passed over the wire 
      or a fixed system parameter).
  
	Output: 
    - The projective point (X4:Z4) in the codomain and
    - the isogenous curve constant A/C. Variables are overwritten because they 
      replace inputs in the routine.
	*/

	t0:=X4^2;
	X:=Z4^2;
	Z:=X4*Z4;
	X4:=A*Z;
	Z:=Z+Z;
	Z4:=Z-X4;
	t0:=t0+X;
	X:=t0+Z;
	Z:=t0-Z;
	X4:=X4+t0;
	X:=X*X4;
	Z:=Z4*Z;
	C:=A-2;
	A:=A+6;
	A:=A+A;				

	return X,Z,A,C;     // Total: 4M+2S+9a

end function;

////////////////////////////////////////////////////////////////////////////////

xTPL:=function(X,Z,A,C)

	/*
	This is NOT the stereotypical Montgomery x-only tripling, since it assumes 
    that the curve constant is projective.  

	Input: 
    - The projective Montgomery x-coordinates of xP=X/Z and 
    - the Montgomery curve constant A4:=4*A.

	Output: 
    - The projective Montgomery x-coordinates of x(2P)=X3/Z3. 
	*/

        t2 := X+Z;
        t0 := X^2;
        t1 := Z^2;
        t2 := t2^2;
        t3 := C*t0;
        t2 := t2-t0;
        t4 := C*t1;
        t2 := t2-t1;
        t5 := t3+t4;
        t2 := A*t2;
        t3 := t3+t3; 
        t4 := t4+t4;
        t3 := t2+t3;
        t4 := t2+t4;
        t3 := t3+t5;
        t4 := t4+t5;
        t2 := t0-t1;
        t0 := t0+t0;
        t1 := t1+t1;
        t2 := t2*t5;
        t1 := t1*t3;
        t0 := t0*t4;
        t1 := t1-t2;
        t0 := t0+t2;
        t1 := t1^2;
        t0 := t0^2;
        X3 := X*t1;
        Z3 := Z*t0;

        return X3,Z3;     // Total: 8M+5S+15a  
	
end function;

////////////////////////////////////////////////////////////////////////////////

xTPLe:=function(X,Z,A,C,e)

	/*
	This function just computes [3^e](X:Z) on a Montgomery curve with 
    projective constant via 3^e repeated triplings.  

	Input: 
    - The projective Montgomery x-coordinates of xP=X/Z and 
    - the Montgomery curve constant A/C.

	Output: 
    - The projective Montgomery x-coordinates of x(eP)=XeP/ZeP. 
	*/
	
	XeP:=X; ZeP:=Z;

	for i:=1 to e do
		XeP,ZeP:=xTPL(XeP,ZeP,A,C);
	end for;

	return XeP,ZeP;

end function;

////////////////////////////////////////////////////////////////////////////////

get_3_isog:=function(X3,Z3)

	/*
	Given a projective point (X3:Z3) of order 3 on a Montgomery curve, this 
    computes the corresponding 3-isogenous curve.

	Input: 
    - The projective point of order three (X3:Z3).

	Output: 
    - The 3-isogenous Montgomery curve with projective coefficient A/C. 
      No coefficients are computed for the evaluation phase as all operations 
      in the evaluation depend on the input point to the isogeny.
	*/

	t0:=X3^2;
	t1:=t0+t0;
	t0:=t0+t1;
	t1:=Z3^2;
	A:=t1^2;
	t1:=t1+t1;
	C:=t1+t1;
	t1:=t0-t1;
	t1:=t1*t0;
	A:=A-t1;  
	A:=A-t1;
	A:=A-t1;
	t1:=X3*Z3;
	C:=C*t1;

	return A,C;			//Total: 3M+3S+8a  

end function;

////////////////////////////////////////////////////////////////////////////////

eval_3_isog:=function(X3,Z3,X,Z)

	/*
	Given a projective point (X3:Z3) of order 3 on a Montgomery curve and a 
    projective point x(P)=(X:Z), this function evaluates the corresponding 
    3-isogeny at x(P): phi(X:Z).

    Input:
    - The projective point (X3:Z3) of order three,
    - the projective Montgomery x-coordinates of x(P)=X/Z.

    Output: 
    - The projective Montgomery x-coordinates of the evaluation of phi at
      (X:Z).
	*/

    t0:=X3*X;       
	t1:=Z3*X;       
	t2:=Z3*Z;
	t0:=t0-t2;              
	t2:=Z*X3;               
	t1:=t1-t2;
	t0:=t0^2;       
	t1:=t1^2;       
	X:=X*t0;        
	Z:=Z*t1;        

	return X,Z;			//Total: 6M+2S+2a  
	
end function;

////////////////////////////////////////////////////////////////////////////////

inv_4_way:=function(z1,z2,z3,z4)

	/*
    This function computes inverses of four elements by sharing the inversions
    via Montgomery's simultaneous inversion trick.

	Input: 
    - The four values to be inverted: z1,z2,z3,z4.
	
    Output: 
    - Their inverses 1/z1,1/z2,1/z3,1/z4 (over-ride variables).
	*/

	t0:=z1*z2;
	t1:=z3*z4;
	t2:=t0*t1;
	t2:=1/t2;
	t0:=t0*t2; 
	t1:=t1*t2; 
	t2:=z3*t0;
	z3:=z4*t0;
	z4:=t2;
	t2:=z1*t1;
	z1:=z2*t1;
	z2:=t2;

	return z1,z2,z3,z4;				//Total: 9M+1I  
	
end function;

////////////////////////////////////////////////////////////////////////////////

distort_and_diff:=function(xP)

	/*
    Given the x-coordinate of an affine point P, this function returns the
    projective x-coordinates of the difference point Q-P, where Q=tau(P) is 
    the image under the distortion map of the point P. 

	Input: 
    - The coordinate xP of the point P=(xP,yP).

	Output: 
    - The point (x(Q-P),z(Q-P)), where Q=tau(P).
	*/

	XD:=xP^2;		
	XD:=XD+1;
	XD:=XD*i;
	ZD:=xP+xP;

	return XD,ZD;	
	
end function;

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/////////////////////// Key exchange functions /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//////////////////////// ALICE KEY GENERATION //////////////////////////////////
/////////////////////// SIMPLE BUT SLOW VERSION ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

keygen_Alice_simple:=function(SK_Alice,params)

    /*
    This function generates Alice's public key from her secret key and the 
    public scheme parameters. It uses a simple but costly loop for traversing 
    the isogeny tree.
    
    Input: 
    - Alice's secret key SK_Alice, which is a random even number between 1 and 
      oA-1,
    - three public parameters params=[XPB,XPA,YPA]: the x-coordinate of PB, 
      and both coordinates of PA.

    Output: 
    - Alice's public key [A,phi_A(x(PB)),phi_A(x(QB)),phi_A(x(QB-PB))].
    */


    A:=0; C:=1; // the starting Montgomery curve (A:C) = (0:1)
    phiPX:=params[1]; phiPZ:=1; 
    phiQX:=-phiPX; phiQZ:=1;	// Q=(-xP,yP), tau(P) but yP instead of yP*i
    							// the "*i" is handled implicitly
    phiDX,phiDZ:=distort_and_diff(phiPX);	// (phiDX:phiDZ):=x(Q-P)

    // Computes x(R)=(RX:RZ) via secret_pt function
    RX0,RX1,RZ:=secret_pt(params[2],params[3],SK_Alice,Alice);
    RX:=RX0+RX1*i;

	isos:=0; mulm:=0;  // operation counters -- ignore these

    // the first iteration is different so not in the main loop
    phiPX,phiPZ:=first_4_isog(phiPX,phiPZ,A); isos+:=1;
    phiQX,phiQZ:=first_4_isog(phiQX,phiQZ,A); isos+:=1;
    phiDX,phiDZ:=first_4_isog(phiDX,phiDZ,A); isos+:=1;
    RX,RZ,A,C:=first_4_isog(RX,RZ,A); isos+:=1;

    // Alice's main loop
    for e:=eA-4 to 0 by -2 do
        
        SX,SZ:=xDBLe(RX,RZ,A,C,e); mulm+:=e div 2;  // computes S=[2^e]R
        A,C,consts:=get_4_isog(SX,SZ);          // computes the 4-isogeny phi
        RX,RZ:=eval_4_isog(consts,RX,RZ); isos+:=1; // R=phi(R)
        phiPX,phiPZ:=eval_4_isog(consts,phiPX,phiPZ); isos+:=1; // P=phi(P)
        phiQX,phiQZ:=eval_4_isog(consts,phiQX,phiQZ); isos+:=1; // Q=phi(Q)
        phiDX,phiDZ:=eval_4_isog(consts,phiDX,phiDZ); isos+:=1; // R=phi(R)

    end for;

    // normalize everything via a 4-way simultaneous inversion
    C,phiPZ,phiQZ,phiDZ:=inv_4_way(C,phiPZ,phiQZ,phiDZ); 
    A:=A*C; 
    phiPX:=phiPX*phiPZ;
    phiQX:=phiQX*phiQZ;
    phiDX:=phiDX*phiDZ;

    PK_Alice:=[A,phiPX,phiQX,phiDX]; // 4 values in Fp2

    "Alice simple keygen requires: ", mulm, "muls-by-4 and ", isos, 
    "4-isogenies";

    return PK_Alice;

end function;

////////////////////////////////////////////////////////////////////////////////
/////////////////////////// ALICE FAST KEYGEN //////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

keygen_Alice_fast:=function(SK_Alice,params,splits,MAX)

    /*
    This function generates Alice's public key from her secret key and the
    public scheme parameters. It uses the optimal way of traversing the
    isogeny tree as described by De Feo, Jao and Plut. 
    
    Input: 
    - Alice's secret key SK_Alice, which is a random even number between 1 and 
      oA-1,
    - three public parameters params=[XPB,XPA,YPA]: the x-coordinate of PB, 
      and both coordinates of PA,
    - the parameter "splits", a vector that guides the optimal route through
      the isogeny tree; it is generated individually for Alice using
      "optimalstrategies.mag" and the ratios of 4-isogeny evaluation versus 
      multiplication-by-4,
    - the parameter "MAX", the maximum number of multiplication-by-4
      computations.

    Output: 
    - Alice's public key [A,phi_A(x(PB)),phi_A(x(QB)),phi_A(x(QB-PB))].
    */

    A:=0; C:=1; // the starting Montgomery curve (A:C) = (0:1)
    phiPX:=params[1]; phiPZ:=1; 
    phiQX:=-phiPX; phiQZ:=1;	// Q=(-xP,yP), tau(P) but yP instead of yP*i
    							// the "*i" is handled implicitly
    phiDX,phiDZ:=distort_and_diff(phiPX);	// (phiDX:phiDZ):=x(Q-P)

    // computes x(R)=(RX:RZ) via secret_pt function
	RX0,RX1,RZ:=secret_pt(params[2],params[3],SK_Alice,Alice);
	RX:=RX0+RX1*i;

	isos:=0; mulm:=0; // operation counters -- ignore these	

	// the first iteration is different so not in the main loop
	phiPX,phiPZ:=first_4_isog(phiPX,phiPZ,A); isos+:=1;
	phiQX,phiQZ:=first_4_isog(phiQX,phiQZ,A); isos+:=1;
	phiDX,phiDZ:=first_4_isog(phiDX,phiDZ,A); isos+:=1;
	RX,RZ,A,C:=first_4_isog(RX,RZ,A); isos+:=1;

    pts:=[];
	index:=0;

    // Alice's main loop
	for row:=1 to MAX-1 do

        // multiply (RX:RZ) until it has order 4, and store intermediate points
        while index lt (MAX - row) do
            Append(~pts, [RX,RZ,index]);
            m := splits[MAX-index-row+1];
	        RX,RZ:=xDBLe(RX,RZ,A,C,2*m); mulm +:= m;
            index +:= m;
        end while;

        // compute the 4-isogeny based on kernel (RX:RZ)
		A,C,consts:=get_4_isog(RX,RZ); 

        // evaluate the 4-isogeny at every point in pts
	    for i:=1 to #pts do 
	    	pts[i][1],pts[i][2]:=eval_4_isog(consts,pts[i][1],pts[i][2]); 
            isos+:=1;
	    end for;

        // evaluate the 4-isogeny at Bob's (intermediate) points 
        // x(P), x(Q), x(Q-P)
		phiPX,phiPZ:=eval_4_isog(consts,phiPX,phiPZ); isos+:=1;
		phiQX,phiQZ:=eval_4_isog(consts,phiQX,phiQZ); isos+:=1;
		phiDX,phiDZ:=eval_4_isog(consts,phiDX,phiDZ); isos+:=1;

        // R becomes the last point in pts and then pts is pruned
		RX:=pts[#pts][1]; 
	    RZ:=pts[#pts][2]; 
	    index:=Integers()!pts[#pts][3];	

		Prune(~pts);

	end for;

    // compute and evaluate the last 4-isogeny
	A,C,consts:=get_4_isog(RX,RZ); 
	phiPX,phiPZ:=eval_4_isog(consts,phiPX,phiPZ); isos+:=1;
	phiQX,phiQZ:=eval_4_isog(consts,phiQX,phiQZ); isos+:=1;
	phiDX,phiDZ:=eval_4_isog(consts,phiDX,phiDZ); isos+:=1;

    // normalize everything via a 4-way simultaneous inversion
	C,phiPZ,phiQZ,phiDZ:=inv_4_way(C,phiPZ,phiQZ,phiDZ);
	A:=A*C; 
	phiPX:=phiPX*phiPZ;
	phiQX:=phiQX*phiQZ;
	phiDX:=phiDX*phiDZ;

	PK_Alice:=[A,phiPX,phiQX,phiDX]; //4 values in Fp2

    "Alice FAST keygen requires: ", mulm, "muls-by-4 and ", isos, 
    "4-isogenies";

	return PK_Alice;

end function;


////////////////////////////////////////////////////////////////////////////////
/////////////////////////// BOB KEY GENERATION /////////////////////////////////
///////////////////////// SIMPLE BUT SLOW VERSION //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

keygen_Bob_simple:=function(SK_Bob,params)

    /*
    This function generates Bob's public key from her secret key and the 
    public scheme parameters. It uses a simple but costly loop for traversing 
    the isogeny tree.
    
    Input: 
    - Bob's secret key SK_Bob, which is a random value between 1 and oB-1, 
    - three public parameters params=[XPA,XPB,YPB]: the x-coordinate of PA, and 
      both coordinates of PB.

    Output: 
    - Bob's public key [A,phi_B(x(PA)),phi_B(x(QA)),phi_B(x(QA-PA))].
    */

    A:=0; C:=1; // the starting Montgomery curve (A:C) = (0:1)
    phiPX:=params[1]; phiPZ:=1; 
    phiQX:=-phiPX; phiQZ:=1;	// Q=(-xP,yP), tau(P) but yP instead of yP*i
    							// the "*i" is handled implicitly
    phiDX,phiDZ:=distort_and_diff(phiPX);	// (phiDX:phiDZ):=x(Q-P)

    // computes x(R)=(RX:RZ) via secret_pt function
    RX0,RX1,RZ:=secret_pt(params[2],params[3],SK_Bob,Bob);
    RX:=RX0+RX1*i;

	isos:=0; mulm:=0; // operation counters -- ignore these	

    // Bob's main loop
    for e:=eB-1 to 0 by -1 do

        SX,SZ:=xTPLe(RX,RZ,A,C,e); mulm+:=e;  // computes S=[3^e]R
        A,C:=get_3_isog(SX,SZ);              // computes the 3-isogeny phi
        RX,RZ:=eval_3_isog(SX,SZ,RX,RZ);  isos+:=1; //R=phi(R)
        phiPX,phiPZ:=eval_3_isog(SX,SZ,phiPX,phiPZ);  isos+:=1; // P=phi(P)
        phiQX,phiQZ:=eval_3_isog(SX,SZ,phiQX,phiQZ);  isos+:=1; // Q=phi(Q)
        phiDX,phiDZ:=eval_3_isog(SX,SZ,phiDX,phiDZ);  isos+:=1; // R=phi(R)

    end for;

    // normalize everything via a 3-way simultaneous inversion
    C,phiPZ,phiQZ,phiDZ:=inv_4_way(C,phiPZ,phiQZ,phiDZ);
    A:=A*C; 
    phiPX:=phiPX*phiPZ;
    phiQX:=phiQX*phiQZ;
    phiDX:=phiDX*phiDZ;

    PK_Bob:=[A,phiPX,phiQX,phiDX]; //4 values in Fp2

    "Bob simple keygen requires: ", mulm, "muls-by-3 and ", isos, 
    "3-isogenies";

    return PK_Bob;

end function;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////// BOB KEYGEN FAST /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

keygen_Bob_fast:=function(SK_Bob,params,splits,MAX)

    /*
    This function generates Bob's public key from his secret key and the 
    public scheme parameters. It uses the optimal way of traversing the
    isogeny tree as described by De Feo, Jao and Plut. 
    
    Input: 
    - Bob's secret key SK_Bob, which is a random value between 1 and oB-1, 
    - three public parameters params=[XPA,XPB,YPB]: the x-coordinate of PA, and 
      both coordinates of PB.
    - the parameter "splits", a vector that guides the optimal route through the 
      isogeny tree; it is generated individually for Bob using 
      "optimalstrategies.m" and the ratios of 3-isogeny evaluation versus 
      multiplication-by-3,
    - the parameter "MAX", the maximum number of multiplication-by-3
      computations.

    Output: 
    - Bob's public key [A,phi_B(x(PA)),phi_B(x(QA)),phi_B(x(QA-PA))].
    */

    A:=0; C:=1;  // the starting Montgomery curve (A:C) = (0:1)
    phiPX:=params[1]; phiPZ:=1; 
    phiQX:=-phiPX; phiQZ:=1;	// Q=(-xP,yP), tau(P) but yP instead of yP*i
    							// the "*i" is handled implicitly
    phiDX,phiDZ:=distort_and_diff(phiPX);	// (phiDX:phiDZ):=x(Q-P)

    // computes x(R)=(RX:RZ) via secret_pt function
    RX0,RX1,RZ:=secret_pt(params[2],params[3],SK_Bob,Bob);
    RX:=RX0+RX1*i;

	pts:=[];
	index:=0;
	
	isos:=0; mulm:=0; // operation counters -- ignore these  

    // Bob's main loop
	for row:=1 to MAX-1 do

        // multiply (RX:RZ) until it has order 3, and store intermediate points
        while index lt (MAX - row) do
            Append(~pts, [RX,RZ,index]);
            m := splits[MAX-index-row+1];
	        RX,RZ:=xTPLe(RX,RZ,A,C,m); mulm +:= m;
            index +:= m;
        end while;

        // compute the 3-isogeny based on kernel (RX:RZ)
		A,C:=get_3_isog(RX,RZ); 

        // evaluate the 3-isogeny at every point in pts
	    for i:=1 to #pts do 
	    	pts[i][1],pts[i][2]:=eval_3_isog(RX,RZ,pts[i][1],pts[i][2]); 
            isos+:=1;
	    end for;

        // evaluate the 3-isogeny at Alice's (intermediate) points 
        // x(P), x(Q), x(Q-P)
		phiPX,phiPZ:=eval_3_isog(RX,RZ,phiPX,phiPZ); isos+:=1;
		phiQX,phiQZ:=eval_3_isog(RX,RZ,phiQX,phiQZ); isos+:=1;
		phiDX,phiDZ:=eval_3_isog(RX,RZ,phiDX,phiDZ); isos+:=1;

        // R becomes the last point in pts and then pts is pruned
		RX:=pts[#pts][1]; 
	    RZ:=pts[#pts][2]; 
	    index:=Integers()!pts[#pts][3];	

		Prune(~pts);

	end for;

    // compute and evaluate the last 3-isogeny
	A,C:=get_3_isog(RX,RZ); 
	phiPX,phiPZ:=eval_3_isog(RX,RZ,phiPX,phiPZ); isos+:=1;
	phiQX,phiQZ:=eval_3_isog(RX,RZ,phiQX,phiQZ); isos+:=1;
	phiDX,phiDZ:=eval_3_isog(RX,RZ,phiDX,phiDZ); isos+:=1;

    // normalize everything via a 4-way simultaneous inversion
    C,phiPZ,phiQZ,phiDZ:=inv_4_way(C,phiPZ,phiQZ,phiDZ);
    A:=A*C; 
    phiPX:=phiPX*phiPZ;
    phiQX:=phiQX*phiQZ;
    phiDX:=phiDX*phiDZ;

    PK_Bob:=[A,phiPX,phiQX,phiDX]; // 4 values in Fp2

    "Bob FAST keygen requires: ", mulm, "muls-by-3 and ", isos, 
    "3-isogenies";

    return PK_Bob;

end function;

////////////////////////////////////////////////////////////////////////////////
////////////////////////// ALICE SHARED SECRET /////////////////////////////////
///////////////////////// SIMPLE BUT SLOW VERSION //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

shared_secret_Alice_simple:=function(SK_Alice,PK_Bob)

    /*
    This function generates Alice's shared secret from her secret key and Bob's
    public key. It uses a simple but costly loop for traversing the isogeny
    tree.
    
    Input: 
    - Alice's secret key SK_Alice, a random even number between 1 and oA-1,
    - Bob's public key PK_Bob=[A,phi_B(x(PA)),phi_B(x(QA)),phi_B(x(QA-PA))].

    Output: 
    - Alice's shared secret: the j-invariant of E_AB.
    */

    A:=PK_Bob[1]; C:=1; // starting on Bob's Montgomery curve
    // computes R=phi_B(xPA)+SK_Alice*phi_B(xQA) via 3 point ladder
    RX,RZ:=LADDER_3_pt(SK_Alice,PK_Bob[2],PK_Bob[3],PK_Bob[4],A,Alice);   

	isos:=0; mulm:=0;

    // the first iteration is different so not in the main loop
    RX,RZ,A,C:=first_4_isog(RX,RZ,A); isos+:=1;

    // Alice's main loop
    for e:=eA-4 to 0 by -2 do
        
        SX,SZ:=xDBLe(RX,RZ,A,C,e); mulm+:=e div 2;   // computes S=[2^e]R
        A,C,consts:=get_4_isog(SX,SZ);      // computes the 4-isogeny phi
        RX,RZ:=eval_4_isog(consts,RX,RZ); isos+:=1; // R=phi(R)

    end for;

    shared_secret_Alice:=j_inv(A,C);

    "Alice simple secret requires: ", mulm, "muls-by-4 and ", isos, 
    "4-isogenies";

    return shared_secret_Alice;

end function;

////////////////////////////////////////////////////////////////////////////////
////////////////////////// ALICE SHARED SECRET /////////////////////////////////
///////////////////////////////  FAST  /////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

shared_secret_Alice_fast:=function(SK_Alice,PK_Bob,params,splits,MAX)

    /*
    This function generates Alice's shared secret from her secret key and Bob's
    public key. It uses the optimal way of traversing the isogeny tree as
    described by De Feo, Jao and Plut. 
    
    Input: 
    - Alice's secret key SK_Alice, a random even number between 1 and oA-1,
    - Bob's public key PK_Bob=[A,phi_B(x(PA)),phi_B(x(QA)),phi_B(x(QA-PA))],
    - the parameter "splits", a vector that guides the optimal route through the 
      isogeny tree; it is generated individually for Alice using 
      "optimalstrategies.m" and the ratios of 4-isogeny evaluation versus 
      multiplication-by-4,
    - the parameter "MAX", the maximum number of multiplication-by-4
      computations.

    Output: 
    - Alice's shared secret: the j-invariant of E_AB.
    */

    A:=PK_Bob[1]; C:=1;  // starting on Bob's Montgomery curve
    // computes R=phi_B(xPA)+SK_Alice*phi_B(xQA) via 3 point ladder
    RX,RZ:=LADDER_3_pt(SK_Alice,PK_Bob[2],PK_Bob[3],PK_Bob[4],A,Alice);   

	isos:=0; mulm:=0;

    // the first iteration is different so not in the main loop
    RX,RZ,A,C:=first_4_isog(RX,RZ,A); isos+:=1;

	pts:=[];
	index:=0;

    // Alice's main loop
	for row:=1 to MAX-1 do

        // multiply (RX:RZ) until it has order 4, and store intermediate points
        while index lt (MAX - row) do
            Append(~pts, [RX,RZ,index]);
            m := splits[MAX-index-row+1];
	        RX,RZ:=xDBLe(RX,RZ,A,C,2*m); mulm +:= m;
            index +:= m;
        end while;

        // compute the 4-isogeny based on kernel (RX:RZ)
		A,C,consts:=get_4_isog(RX,RZ); 

        // evaluate the 4-isogeny at every point in pts
	    for i:=1 to #pts do 
	    	pts[i][1],pts[i][2]:=eval_4_isog(consts,pts[i][1],pts[i][2]); 
            isos+:=1;
	    end for;

        // R becomes the last point in pts and then pts is pruned
		RX:=pts[#pts][1]; 
	    RZ:=pts[#pts][2]; 
	    index:=Integers()!pts[#pts][3];	

		Prune(~pts);

	end for;

    // compute the last 4-isogeny
	A,C,consts:=get_4_isog(RX,RZ); 

    // compute the j Invariant of E_AB
    shared_secret_Alice:=j_inv(A,C);

    "Alice FAST secret requires: ", mulm, "muls-by-4 and ", isos, "4-isogenies";

    return shared_secret_Alice;

end function;

////////////////////////////////////////////////////////////////////////////////
////////////////////////// BOB'S SHARED SECRET /////////////////////////////////
///////////////////////// SIMPLE BUT SLOW VERSION //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

shared_secret_Bob_simple:=function(SK_Bob,PK_Alice)

    /*
    This function generates Bob's shared secret from his secret key and Alice's
    public key. It uses a simple but costly loop for traversing the isogeny 
    tree.
    
    Input: 
    - Bob's secret key SK_Bob, a random number between 1 and oB-1,
    - Alice's public key PK_Alice=[A,phi_A(x(PB)),phi_A(x(QB)),phi_A(x(QB-PB))].

    Output: 
    - Bob's shared secret: the j-invariant of E_BA.
    */

    A:=PK_Alice[1]; C:=1; // starting on Alice's Montgomery curve
    // computes R=phi_A(xPB)+SK_Bob*phi_A(xQB) via 3 point ladder
    RX,RZ:=LADDER_3_pt(SK_Bob,PK_Alice[2],PK_Alice[3],PK_Alice[4],A,Bob);   

	isos:=0; mulm:=0;

    // Bob's main loop
    for e:=eB-1 to 0 by -1 do

        SX,SZ:=xTPLe(RX,RZ,A,C,e); mulm+:=e; // computes S=[3^e]R
        A,C:=get_3_isog(SX,SZ); // computes the 3-isogeny phi
        RX,RZ:=eval_3_isog(SX,SZ,RX,RZ); isos+:=1; // R=phi(R)

    end for;

    // compute the j-invariant of E_BA
    shared_secret_Bob:=j_inv(A,C);

    "Bob simple secret requires: ", mulm, "muls-by-3 and ", isos, "3-isogenies";

    return shared_secret_Bob;

end function;

////////////////////////////////////////////////////////////////////////////////
////////////////////////// BOB'S SHARED SECRET /////////////////////////////////
//////////////////////////////// FAST //////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

shared_secret_Bob_fast:=function(SK_Bob,PK_Alice,params,splits,MAX)

    /*
    This function generates Bob's shared secret from his secret key and Alice's
    public key. It uses the optimal way of traversing the isogeny tree as
    described by De Feo, Jao and Plut. 
    
    Input: 
    - Bob's secret key SK_Bob, a random number between 1 and oB-1,
    - Alice's public key PK_Alice=[A,phi_A(xPB),phi_A(xQB),phi_A(x(QB-PB))],
    - the parameter "splits", a vector that guides the optimal route through the 
      isogeny tree; it is generated individually for Bob using 
      "optimalstrategies.m" and the ratios of 3-isogeny evaluation versus 
      multiplication-by-3,
    - the parameter "MAX", the maximum number of multiplication-by-3
      computations.

    Output: 
    - Bob's shared secret: the j-invariant of E_BA.
    */

    A:=PK_Alice[1]; C:=1; // starting on Alice's Montgomery curve
    // computes R=phi_A(xPB)+SK_Bob*phi_A(xQB) via 3 point ladder
    RX,RZ:=LADDER_3_pt(SK_Bob,PK_Alice[2],PK_Alice[3],PK_Alice[4],A,Bob);   

	pts:=[];
	index:=0;
	
	isos:=0; mulm:=0;

    // Bob's main loop
	for row:=1 to MAX-1 do

        // multiply (RX:RZ) until it has order 3, and store intermediate points
        while index lt (MAX - row) do
            Append(~pts, [RX,RZ,index]);
            m := splits[MAX-index-row+1];
	        RX,RZ:=xTPLe(RX,RZ,A,C,m); mulm +:= m;
            index +:= m;
        end while;

        // compute the 3-isogeny based on kernel (RX:RZ)
		A,C:=get_3_isog(RX,RZ); 

        // evaluate the 3-isogeny at every point in pts
	    for i:=1 to #pts do 
	    	pts[i][1],pts[i][2]:=eval_3_isog(RX,RZ,pts[i][1],pts[i][2]); 
            isos+:=1;
	    end for;

        // R becomes the last point in pts and then pts is pruned
		RX:=pts[#pts][1]; 
	    RZ:=pts[#pts][2]; 
	    index:=Integers()!pts[#pts][3];	

		Prune(~pts);

	end for;

    // compute the last 3-isogeny
	A,C:=get_3_isog(RX,RZ); 

    // compute the j Invariant of E_BA
    shared_secret_Bob:=j_inv(A,C);

    "Bob FAST secret requires: ", mulm, "muls-by-3 and ", isos, "3-isogenies";

    return shared_secret_Bob;

end function;

////////////////////////////////////////////////////////////////////////////////
///////////////////////// Key exchange testing /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

MAX_Alice:=185;
MAX_Bob:=239;

params_Alice:=[XPB,XPA,YPA];
params_Bob:=[XPA,XPB,YPB];

"====================================================================";
"Generating secret keys...";
SK_Alice:=Random(1, (oA div lA)-1)*lA; // Random even number between 1 and oA-1 
SK_Bob:=Random(1, (oB div lB)-1)*lB; // Random multiple of lB between 1 and oB-1 
"Done with secret keys.";
"====================================================================";

"Generating Alice's public key... (simple algorithm).";
PK_Alice:=keygen_Alice_simple(SK_Alice,params_Alice);
"Generating Alice's public key... (fast algorithm).";
PK_Alice_fast:=keygen_Alice_fast(SK_Alice,params_Alice,splits_Alice,MAX_Alice);
"Done with Alice's public key.\n";

"Result from simple key gen equal to result from fast key gen?", 
PK_Alice eq PK_Alice_fast;
"====================================================================";

"Generating Bob's public key... (simple algorithm).";
PK_Bob:=keygen_Bob_simple(SK_Bob,params_Bob);
"Generating Bob's public key... (fast algorithm).";
PK_Bob_fast:=keygen_Bob_fast(SK_Bob,params_Bob,splits_Bob,MAX_Bob);
"Done with Bob's public key.\n";

"Result from simple key gen equal to result from fast key gen?", 
PK_Bob eq PK_Bob_fast;
"====================================================================";
//*
// Optional validation of public keys.
load "Validate.mag";

"Alice's PK valid?", 
validate_PKA(PK_Alice[1],PK_Alice[2],PK_Alice[3],PK_Alice[4],eB);
"Bob's PK valid?", 
validate_PKB(PK_Bob[1],PK_Bob[2],PK_Bob[3],PK_Bob[4],eA);
"====================================================================";
//*/

"Generating shared secret for Alice... (simple algorithm).";
secret_Alice:=shared_secret_Alice_simple(SK_Alice,PK_Bob);
"Generating shared secret for Alice... (fast algorithm).";
secret_Alice_fast:=shared_secret_Alice_fast(SK_Alice,PK_Bob_fast,
                                         params_Alice,splits_Alice,MAX_Alice);
"Done with Alice's shared secret computation.\n";

"Results from simple and fast algorithms equal?", 
secret_Alice eq secret_Alice_fast;
"====================================================================";

"Generating shared secret for Bob... (simple algorithm).";
secret_Bob:=shared_secret_Bob_simple(SK_Bob,PK_Alice);
"Generating shared secret for Bob... (fast algorithm).";
secret_Bob_fast:=shared_secret_Bob_fast(SK_Bob,PK_Alice_fast,params_Bob,
                                                       splits_Bob,MAX_Bob);
"Done with Bob's shared secret computation.\n";

"Results from simple and fast algorithms equal?", secret_Bob eq secret_Bob_fast;
"====================================================================\n";
"Shared secrets are equal?", secret_Alice_fast eq secret_Bob_fast;
"";
"====================================================================";

